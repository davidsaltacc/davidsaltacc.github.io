<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Image from Images TESTING</title>
    <link rel="stylesheet" type="text/css" href="../../styles.css">
    <style>
        body {
            background-color: black;
        }

        html,
        body {
            margin: 0;
            padding: 0;
        }

        canvas {
            display: block;
            background-color: black;
        }

        p,
        a {
            margin: 0px;
            font-family: system-ui;
            font-size: 20px;
            margin-bottom: 5px;
        }
    </style>
</head>

<body>
    <script src="allemojis.js"></script>
    <script>

        var debugging = true;
        var imagesPerGeneration = 1000;
        var amntChildren = 10;
        var keepImages = 100;
        var maxScale = 5;
        var maxMutationAmount = 0.3;
        var generations = 3;
        var amountEmojis = 1000;

        var imageCanvas = document.createElement("canvas"),
            bufferCanvas = document.createElement("canvas"),
            resultCanvas = document.createElement("canvas"),
            width = imageCanvas.width = bufferCanvas.width = resultCanvas.width = window.innerWidth,
            height = imageCanvas.height = bufferCanvas.height = resultCanvas.height = window.innerHeight,
            imageCtx = imageCanvas.getContext("2d", { willReadFrequently: true }),
            bufferCtx = bufferCanvas.getContext("2d", { willReadFrequently: true }),
            resultCtx = resultCanvas.getContext("2d", { willReadFrequently: true }),
            file = document.createElement("input");
        
        file.type = "file";
        document.body.appendChild(file);
        document.body.appendChild(resultCanvas);
        // document.body.appendChild(bufferCanvas);
        document.body.appendChild(imageCanvas);
        file.addEventListener("change", function () {
            var img = new Image();
            img.onload = function () {
                width = imageCanvas.width = bufferCanvas.width = resultCanvas.width = img.width;
                height = imageCanvas.height = bufferCanvas.height = resultCanvas.height = img.height;
                imageCtx.drawImage(img, 0, 0, width, height);
                var drawLoop = draw();
                function updateCanvas() {
                    drawLoop.next();
                    if (!drawLoop.done) {
                        requestAnimationFrame(updateCanvas);
                    }
                }
                requestAnimationFrame(updateCanvas);
            };
            img.src = URL.createObjectURL(file.files[0]);
        });

        function colorDifference(rgb1, rgb2) {
            var diff = 0;
            for (var v = 0; v < rgb1.length; v++) {
                diff += (rgb1[v] - rgb2[v]) * (rgb1[v] - rgb2[v]);
            }
            return Math.sqrt(diff);
        }

        function colorDifferenceCanvas(ctx1, ctx2) {
            var data1 = ctx1.getImageData(0, 0, width, height);
            var data2 = ctx2.getImageData(0, 0, width, height);
            var diff = 0;
            for (var y = 0; y < height; y++) {
				for (var x = 0; x < width; x++) {
                    var index = y * width + x;
                    var pixel1 = [data1.data[index], data1.data[index + 1], data1.data[index + 2]];
                    var pixel2 = [data2.data[index], data2.data[index + 1], data2.data[index + 2]];
                    diff += colorDifference(pixel1, pixel2);
                }
            }
            return diff;
        }

        function loadImage(src) {
            return new Promise(function(resolve, reject) {
                var img = new Image();
                img.crossOrigin = "anonymous";
                img.onload = function() {
                    resolve(img);
                };
                img.onerror = reject;
                img.src = src;
            });
        }

        function debug(o) {
            if (debugging) {
                console.log(o);
            }
        }

        function computeScores(images) {
            for (var i = 0; i < images.length; i++) {
                debug("Computing Score for Image " + i + " / " + images.length + "...")
                // compute score (lower -> better)

                if (images[i].score != -1) {
                    continue;
                }

                // get color diff resultCanvas and imageCanvas
                debug("Computing diff1...");
                var diff1 = colorDifferenceCanvas(resultCtx, imageCtx);

                // get color diff resultCanvas + current Img and imageCanvas
                // draw resultCtx + current Img to bufferCanvas
                debug("Drawing resultCtx and the current Image to the bufferCanvas...");
                bufferCtx.putImageData(resultCtx.getImageData(0, 0, width, height), 0, 0);

                var image = images[i].img;
                bufferCtx.save();
                bufferCtx.translate(images[i].x, images[i].y);
                bufferCtx.rotate((images[i].rotation * Math.PI) / 180);
                bufferCtx.scale(images[i].scale, images[i].scale);
                bufferCtx.drawImage(image, -image.width / 2, -image.height / 2);
                bufferCtx.restore();

                debug("Computing diff2...");
                var diff2 = colorDifferenceCanvas(resultCtx, bufferCtx);

                // score = diff1 - diff2
                debug("Computing Score...");
                images[i].score = diff1 - diff2;
            }
            return images;
        }

        function generation(images, children) {
            debug("Starting Score Computations...");
            images = computeScores(images);

            debug("Sorting Images by Score...");
            images.sort((a, b) => a.score - b.score);
            debug("Eliminating Images...");
            images = images.slice(0, keepImages);

            if (children) {
                debug("Creating Children...");
                var imgLen = images.length;
                for (var i = 0; i < imgLen; i++) {
                    debug("Creating Children for Image " + i + "...");
                    for (var j = 0; j < amntChildren; j++) {
                        images.push({
                            img: images[i].img,
                            x: images[i].x + images[i].x * (Math.random() * 2 - 1) * maxMutationAmount,
                            y: images[i].y + images[i].y * (Math.random() * 2 - 1) * maxMutationAmount,
                            scale: images[i].scale + images[i].scale * (Math.random() * 2 - 1) * maxMutationAmount,
                            rotation: images[i].rotation + images[i].rotation * (Math.random() * 2 - 1) * maxMutationAmount,
                            score: -1
                        });
                    }
                }
            }
            return images;
        }

        async function* draw() {
            for (var imgI = 0; imgI < amountEmojis; imgI++) { // TODO test and animate the process
                debug("Downloading all Images...");
                var images = [];
                var allEmojisLength = allemojis.length;
                for (var i = 0; i < imagesPerGeneration; i++) {
                    var imageSrc = "https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/72x72/" + allemojis[Math.floor(Math.random() * allEmojisLength)];
                    images.push({
                        img: await loadImage(imageSrc),
                        x: Math.random() * width,
                        y: Math.random() * height,
                        scale: Math.random() * maxScale,
                        rotation: Math.random() * 360,
                        score: -1
                    });
                    debug("Image " + i + " / " + imagesPerGeneration + " done");
                }

                for (var gen = 0; gen < generations; gen++) {
                    images = generation(images, gen < generations - 1);
                }
                var finalImage = images[0];
                resultCtx.save();
                resultCtx.translate(finalImage.x, finalImage.y);
                resultCtx.rotate((finalImage.rotation * Math.PI) / 180);
                resultCtx.scale(finalImage.scale, finalImage.scale);
                resultCtx.drawImage(finalImage.img, -finalImage.img.width / 2, -finalImage.img.height / 2);
                resultCtx.restore();
                yield;
            }
        }

    </script>
</body>

</html>