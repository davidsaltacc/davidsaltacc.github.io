<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Fractals</title>
    <link rel="stylesheet" href="../../styles.css">
    <meta property="og:type" content="website">
    <meta property="og:title" content="Fractals">
    <meta property="og:description" content="A fractal explorer">
    <meta property="og:image" content="/assets/thumbnail_fractals.html.png">
    <meta property="og:url" content="https://davidsaltacc.github.io/pages/generative-art/fractals">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Fractals">
    <meta name="twitter:description" content="A fractal explorer">
    <meta name="twitter:image" content="/assets/thumbnail_fractals.html.png">
    <link rel="shortcut icon" type="image/png" href="../../assets/favicon.png">
    <style>
        * {
            border-radius: 2px;
            border-style: none;
        }
        body {
            margin: 0;
            padding: 0;
        }
        p {
            margin: 1px;
        }
        .container {
            max-width: 98%;
        }
        input {
            width: 50%;
        }
        #constantRe, #constantIm {
            width: 25%;
        }
        #url {
            word-wrap: break-word;
        }
        #unsupported {
            display: none;
            position: fixed;
            z-index: 99;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
        }
    </style>
</head>
    <div id="unsupported">
        <h1>You have been detected as a mobile user. Sadly, this website can only be viewed on Desktop browsers.</h1>
    </div>
    <div class="container">
        <br>
        <h3>Fractal Selection</h3>
        <button onclick="setFractal('mandelbrot')">Mandelbrot</button>
        <button onclick="setFractal('burning ship')">Burning ship</button>
        <button onclick="setFractal('celtic')">Celtic</button>
        <button onclick="setFractal('tricorn')">Tricorn</button>
        <button onclick="setFractal('duck')">Duck</button>
        <button onclick="setFractal('butt')">Ass</button>
        <button onclick="setFractal('sine')">Sine Juliaset</button>
        <button onclick="setFractal('popcorn')">Popcorn</button>
        <button onclick="setFractal('thorn')">Thorn</button>
        <button onclick="setFractal('tan mandelbrot')">Tan Mandelbrot</button>
        <button onclick="setFractal('henon')">Henon</button>
        <button onclick="setFractal('duffing')">Duffing</button>
        <button onclick="setFractal('chirikov')">Chirikov</button>
        <button onclick="setFractal('ikeda')">Ikeda</button>
        <button onclick="setFractal('feather')">Feather</button>
        <button onclick="setFractal('heart')">Heart</button>
        <button onclick="setFractal('ass 2')">Ass 2</button>
        <button onclick="setFractal('triangle')">Triangle</button>
        <h3>Colormap Selection</h3>
        <button onclick="setColormap('classic')">Classic</button>
        <button onclick="setColormap('ultra fractal')">Ultra Fractal Default</button>
        <button onclick="setColormap('red and blue')">Red and Blue</button>
        <p>Color offset:</p>
        <input type="range" min="0" max="1" step="0.001" value="0" id="coloroffset" oninput="updateSettings();">
        <h3>Color Method Selection</h3>
        <button onclick="setColormethod('terraced')">Terraced</button>
        <button onclick="setColormethod('smooth')">Smooth</button>
        <button onclick="setColormethod('rings')">Rings</button>
        <button onclick="setColormethod('stripes')">Stripes</button>
        <button onclick="setColormethod('interior')">Interior</button>
        <h3>Settings</h3>
        <p>Escape Radius:</p>
        <input type="number" id="radius" value="2" onchange="updateSettings();">
        <p>Iterations:</p>
        <input type="number" id="iterations" value="200" onchange="updateSettings();">
        <p>Canvas Size:</p>
        <input type="number" id="size" value="500" onchange="updateSize(parseInt(document.getElementById('size').value));">
        <p>Juliaset Constant:</p>
        <input type="number" id="constantRe" value="0" onchange="updateSettings();">
        <input type="number" id="constantIm" value="0" onchange="updateSettings();">
        <p>Interpolate between normal and juliaset:</p>
        <input type="range" id="nji" value="1" min="0" max="1" step="0.001" oninput="updateSettings();">
        <h3>Save Settings:</h3>
        <a id="url" href="">_</a>
        <h3>Visit the old version:</h3>
        <a href="https://davidsaltacc.github.io/pages/generative-art/fractals-old">davidsaltacc.github.io/pages/generative-art/fractals-old</a>
        <h3>Side Note:</h3>
        <p>This project is still very early in development. This means, new features will be added in the future. Until everything is finished, bugs might occur, things might break. If you find anything, please <a href="https://github.com/davidsaltacc/davidsaltacc.github.io/issues/new">open a issue on github.</a></p>
        <h3>What are fractals and what is this?</h3>
        <a href="https://en.wikipedia.org/wiki/Fractal">https://en.wikipedia.org/wiki/Fractal</a><br>
        <a href="https://en.wikipedia.org/wiki/Mandelbrot_set">https://en.wikipedia.org/wiki/Mandelbrot_set</a><br>
        <a href="https://en.wikipedia.org/wiki/Julia_set">https://en.wikipedia.org/wiki/Julia_set</a><br>
        <a href="https://blinry.org/mandelbrot/">https://blinry.org/mandelbrot</a><br>
        <a href="https://alonso-delarte.medium.com/a-quick-explanation-of-the-mandelbrot-set-41102d7182b">https://alonso-delarte.medium.com/a-quick-explanation-of-the-mandelbrot-set-41102d7182b</a>
        <h3>Special Thanks:</h3>
        <p><a href="https://nathansolomon1678.github.io/fractals">This</a> project by nathansolomon1678 on github, where I got a lot of insipration (and maybe code ;) from</p>
        <p>Paul Bourke, especially his website page on fractals <a href="http://www.paulbourke.net/fractals/">here</a>, where I got lots of the fractals and insipration from</p>
        <p>CodeParade (HackerPoet on github) for <a href="https://github.com/HackerPoet/FractalSoundExplorer">this</a> project, where I got the code for the feather fractal from</p>
        <p>All the amazing people who discovered all of these fractals and made this project possible</p>
        <p>My friends (they did nothing for this project but still thanks)</p>
        <p>You, for visiting and testing my project!</p>
    </div>
    <script type="x-shader/x-vertex" id="vert-shader">#version 300 es
        precision highp float;
        in vec2 position;
        out vec2 vertex_position;
        void main() {
            gl_Position = vec4(position, 0., 1.);
            vertex_position = position;
        }
    </script>
    <script type="x-shader/x-fragment" id="frag-shader">#version 300 es
        precision highp float;
        in vec2 vertex_position;
        out vec4 fragmentColor;

        uniform vec2 canvas_dimensions;
        uniform vec2 center;
        uniform vec2 julia_constant;
        uniform float scale_factor;
        uniform float radius;
        uniform int juliaset;
        uniform int max_iterations;
        uniform int fractal_type;
        uniform int colorscheme;
        uniform float color_offset;
        uniform int color_method;
        uniform float main_juliaset_lerp;

        #define pi 3.141592653589793
        #define e 2.718281828459045

        float square(float x) {
            return x * x;
        }
        float magnitude(vec2 z) {
            return sqrt(square(z.x) + square(z.y));
        }
        float power(float n, float p) {
            if (p == 1.) {
                return n;
            }
            if (p == 2.) {
                return n * n;
            }
            return pow(n, p);
        }

        float weierstrass(float x) {
            x *= 2.;
            return cos(x) + cos(3. * x) / 2. + cos(9. * x) / 4. + cos(27. * x) / 8. + cos(81. * x) / 16.;
        }

        float cubic_interpolation(float a, float b, float c, float d, float x) {
            return b +
                   x * (.5 * c - .5 * a) +
                   x * x * (a - 2.5 * b + 2. * c - .5 * d) +
                   x * x * x * (-.5 * a + 1.5 * b - 1.5 * c + .5 * d);
        }

        vec4 mix_cubic(vec3 color0, vec3 color1, vec3 color2, vec3 color3, float x) {
            return vec4(
                cubic_interpolation(color0.r, color1.r, color2.r, color3.r, x),
                cubic_interpolation(color0.g, color1.g, color2.g, color3.g, x),
                cubic_interpolation(color0.b, color1.b, color2.b, color3.b, x),
                1.
            );
        }

        vec4 classic_colorscheme(float x) {
            x *= pi * 2.;
            return vec4(
                .5 + sin(x) / 2.,
                .5 + sin(x + 1.) / 2.,
                .5 + sin(x + 2.) / 2.,
                1.
            );
        }

        vec4 wikipedia_colorscheme(float x) {
            vec3 blue = vec3(0., 0.03, 0.39);
            vec3 lightblue = vec3(0.12, 0.42, 0.8);
            vec3 white = vec3(0.93, 1., 1.);
            vec3 orange = vec3(1., 0.66, 0.);
            vec3 black = vec3(0., 0.1, 0.007);
            x = fract(x) * 5.;
            if (x < 1.) {
                return mix_cubic(blue, lightblue, white, orange, fract(x));
            }
            if (x < 2.) {
                return mix_cubic(lightblue, white, orange, black, fract(x));
            }
            if (x < 3.) {
                return mix_cubic(white, orange, black, blue, fract(x));
            }
            if (x < 4.) {
                return mix_cubic(orange, black, blue, lightblue, fract(x));
            }
            if (x < 5.) {
                return mix_cubic(black, blue, lightblue, white, fract(x));
            }
            return vec4(black, 1.);
        }

        vec4 red_blue_colorscheme(float x) {
            vec3 red = vec3(1., .3, 0.);
            vec3 white = vec3(1., 1., 1.);
            vec3 blue = vec3(0.2, 0.4, 1.);
            vec3 black = vec3(0., 0., 0.);
            x = fract(x) * 4.;
            if (x < 1.) {
                return mix_cubic(black, red, white, blue, fract(x));
            }
            if (x < 2.) {
                return mix_cubic(red, white, blue, black, fract(x));
            }
            if (x < 3.) {
                return mix_cubic(white, blue, black, red, fract(x));
            }
            if (x < 4.) {
                return mix_cubic(blue, black, red, white, fract(x));
            }
            return vec4(black, 1.);
        }

        vec4 color(float x) {
            x += color_offset;
            if (colorscheme == 0) {
                return classic_colorscheme(x);
            }
            if (colorscheme == 1) {
                return wikipedia_colorscheme(x);
            } 
            if (colorscheme == 2) {
                return red_blue_colorscheme(x);
            }
        }

        vec2 iteration(vec2 z, vec2 c, int type) {
            if (type == 0) {
                // Mandelbrot
                return c + vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y);
            } 
            if (type == 1) {
                // Burning ship
                return c + vec2(z.x * z.x - z.y * z.y, abs(2. * z.x * z.y));
            }
            if (type == 2) {
                // Celtic
                return c + vec2(abs(z.x * z.x - z.y * z.y), 2. * z.x * z.y);
            }
            if (type == 3) {
                // Tricorn
                return c + vec2(z.x * z.x - z.y * z.y, -2. * z.x * z.y);
            }
            if (type == 4) {
                // Duck
                return c + vec2(power(abs(z.x), 2.) - power(abs(z.y), 2.), 2. * z.x * abs(z.y));
            }
            if (type == 5) {
                // Butt
                return c + vec2(z.x * z.x * z.x - z.y * z.y * abs(z.y), 2. * z.x * z.y);
            }
            if (type == 6) {
                // Juliaset Sine (very high radius required)
                return c * vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y));
            }
            if (type == 7) {
                // Popcorn (ideal radius ca ~2)
                return vec2(z.x - c.x * (z.y + tan(3. * z.y)), z.y - c.y * (z.x + tan(3. * z.x)));
            }
            if (type == 8) {
                // Thorn (very high radius required)
                return vec2(z.x / cos(z.y), z.y / sin(z.x)) + c;
            }
            if (type == 9) {
                // Tan Mandelbrot (ideal radius ca ~1.5)
                vec2 mand = c + vec2(power(abs(z.x), 2.) - power(abs(z.y), 2.), 2. * z.x * z.y);
                float cosx = cos(mand.x);
                float sinx = sin(mand.x);
                float sinhy = sinh(mand.y);
                float coshy = cosh(mand.y);
                float d = (cosx * coshy - sinx * sinhy);
                float re = (sinx * coshy) / d;
                float im = (cosx * sinhy) / d;
                return vec2(re, im);
            }
            if (type == 10) {
                // Henon (radius rather high, ~20000)
                return vec2(1. - c.x * z.x * z.x + z.y, c.y * z.x);
            }
            if (type == 11) {
                // Duffing (radius not too important, ~200)
                return vec2(z.y, -1. * c.y * z.x + c.x * z.y - z.y * z.y * z.y);
            }
            if (type == 12) {
                // Chirikov (low radius, ~3)
                return vec2(z.x + c.x * z.y, c.y + c.y * sin(z.x));
            }
            if (type == 13) {
                // Ikeda (radius rather high, ~20000)
                float t = 0.4 - 6. / (1. + square(z.x) + square(z.y));
                float sin_t = sin(t);
                float cos_t = cos(t);
                return vec2(1. + c.x * (z.x * cos_t - z.y * sin_t), c.y * (z.x * sin_t + z.y * cos_t));
            }
            if (type == 14) {
                // Feather (radius around ~200 or lower)
                float dr = 1. + z.x * z.x;
                float di = z.y * z.y;
                float zr = z.x * z.x * z.x - 3. * z.x * z.y * z.y;
                float zi = 3. * z.x * z.x * z.y - z.y * z.y * z.y;
                float dvr = (zr * dr + zi * di) / (dr * dr + di * di);
                float dvi = (zi * dr - zr * di) / (dr * dr + di * di);
                return vec2(dvr, dvi) + c;
            }
            if (type == 15) {
                // Heart
                return vec2(c.x, c.y * -1.) + vec2(2. * z.x * z.y, abs(z.y) - abs(z.x));
            }
            if (type == 16) {
                // Ass 2
                return c + vec2(sinh(z.x) * sin(z.y), cosh(z.y) * cos(z.x));
            }
            if (type == 17) {
                // Triangle
                return c + vec2(sin(z.x) * sinh(z.y), cos(z.y) * cosh(z.x));
            }
        }

        void main() {
            vec2 window = canvas_dimensions / min(canvas_dimensions.x, canvas_dimensions.y);
            vec2 original_z = vertex_position * window / scale_factor + center;
            original_z = vec2(original_z.x, original_z.y * -1.); // its upside down somehow?
            vec2 last_z = original_z;
            vec2 z = original_z;
            vec2 c = original_z;
            if (juliaset == 1) {
                if (main_juliaset_lerp == 1.) {
                    c = vec2(julia_constant.x, julia_constant.y * -1.); // it gets inverted for some reason;
                } else if (main_juliaset_lerp == 0.) {
                    c = original_z;
                } else {
                    c = (1. - main_juliaset_lerp) * original_z + main_juliaset_lerp * vec2(julia_constant.x, julia_constant.y * -1.);;
                }
            }
            float distance_to_orbit_trap = 100000000.;
            float color_v = 0.;
            bool color_black = false;
            float stripe = 0.;
            
            for (int i = 0; i <= max_iterations; i++) {
                z = iteration(z, c, fractal_type);
                if (color_method == 0) {
                    if (magnitude(z) > radius) {
                        color_v = float(i) / float(max_iterations);
                        break;
                    } else if (i == max_iterations) {
                        color_black = true;
                    }
                } else if (color_method == 1) {
                    if (magnitude(z) > radius) {
                        float float_iters = float(i) + log(radius / magnitude(last_z)) / log(magnitude(z) / magnitude(last_z));
                        color_v = float_iters / float(max_iterations);
                        break;
                    } else if (i == max_iterations) {
                        color_black = true;
                    }
                } else if (color_method == 2) {
                    if (magnitude(z) > radius) {
                        color_black = true;
                        break;
                    } else {
                        color_v = log(magnitude(z));
                    }
                } else if (color_method == 3) {
                    distance_to_orbit_trap = min(distance_to_orbit_trap, abs(magnitude(z) - radius));
                    color_v = -log(distance_to_orbit_trap);
                } else if (color_method == 4) {
                    if (magnitude(z) > radius) {
                        float float_iters = float(i) + log(radius / magnitude(last_z)) / log(magnitude(z) / magnitude(last_z));
                        stripe += weierstrass(atan(z.y, z.x)) * fract(float_iters);
                        color_v = float_iters / square(log(float_iters)) + 40. * stripe / float_iters;
                        color_v /= float(max_iterations);
                        break;
                    } else if (i == max_iterations) {
                        color_black = true;
                    } else {
                        stripe += weierstrass(atan(z.y, z.x));
                    }
                }
                last_z = z;
            }
            if (color_black) {
                fragmentColor = vec4(0., 0., 0., 1.);
            } else {
                fragmentColor = color(color_v);
            }
        }
    </script>
    <script>
        function unsupported_device() {
            let check = false;
            (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))) check = true;})(navigator.userAgent||navigator.vendor||window.opera);
            return check;
        };

        if (unsupported_device()) {
            document.getElementById("unsupported").style.display = "block";
            
            // crash, best way to stop the rest from executing at all
            throw new Error("unsupported device detected");
        }

        var canvasMain = document.createElement("canvas");
        var canvasJul = document.createElement("canvas");
        var container = document.getElementsByClassName("container")[0];
        container.prepend(canvasJul);
        container.prepend(canvasMain);
        canvasMain.width = 500;
        canvasMain.height = 500;
        canvasJul.width = 500;
        canvasJul.height = 500;
        var glmain = canvasMain.getContext("webgl2");
        var gljul = canvasJul.getContext("webgl2");

        function loadShaders(gl) {
            if (!gl) {
                alert("Your browser does not support WebGL.");
                return null;
            }
            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
            gl.clearColor(0., 0., 0., 1.);
            gl.clear(gl.COLOR_BUFFER_BIT);
            var source = document.getElementById("vert-shader").innerText;
            var vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, source);
            gl.compileShader(vertexShader);
            var vertShaderLog = gl.getShaderInfoLog(vertexShader);
            source = document.getElementById("frag-shader").innerText;
            var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, source);
            gl.compileShader(fragmentShader);
            var fragShaderLog = gl.getShaderInfoLog(fragmentShader);
            var program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            gl.detachShader(program, vertexShader);
            gl.detachShader(program, fragmentShader);
            gl.deleteShader(vertexShader);
            gl.deleteShader(fragmentShader);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                alert(gl.getProgramInfoLog(program));
                console.log(vertShaderLog);
                console.log(fragShaderLog);
                return null;
            }
            var vertexArray = new Float32Array([-1., -1., 1., -1., 1., 1., -1., 1.]);
            var vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertexArray, gl.STATIC_DRAW);
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            var aVertexPosition = gl.getAttribLocation(program, "position");
            gl.enableVertexAttribArray(aVertexPosition);
            gl.vertexAttribPointer(aVertexPosition, 2, gl.FLOAT, false, 0, 0);
            gl.useProgram(program);
            return program;
        }

        var programMain = loadShaders(glmain);
        var programJul = loadShaders(gljul);

        var julia_constant = [0, 0];

        function uniform(gl, program,
            canvas_dimensions,
            center,
            julia_constant,
            scale_factor,
            radius,
            juliaset,
            max_iterations,
            fractal_type,
            colorscheme,
            color_offset,
            color_method,
            main_juliaset_lerp
        ) {
            gl.uniform2fv(gl.getUniformLocation(program, "canvas_dimensions"), canvas_dimensions);
            gl.uniform2fv(gl.getUniformLocation(program, "center"), center);
            gl.uniform2fv(gl.getUniformLocation(program, "julia_constant"), julia_constant);
            gl.uniform1f(gl.getUniformLocation(program, "scale_factor"), scale_factor);
            gl.uniform1f(gl.getUniformLocation(program, "radius"), radius);
            gl.uniform1i(gl.getUniformLocation(program, "juliaset"), juliaset);
            gl.uniform1i(gl.getUniformLocation(program, "max_iterations"), max_iterations);
            gl.uniform1i(gl.getUniformLocation(program, "fractal_type"), fractal_type);
            gl.uniform1i(gl.getUniformLocation(program, "colorscheme"), colorscheme);
            gl.uniform1f(gl.getUniformLocation(program, "color_offset"), color_offset);
            gl.uniform1i(gl.getUniformLocation(program, "color_method"), color_method);
            gl.uniform1f(gl.getUniformLocation(program, "main_juliaset_lerp"), main_juliaset_lerp);
        }

        var radius = 2000000;
        var max_iterations = 200;
        var fractal_type = 0;
        var color_method = 0;
        var colorscheme = 0;
        var color_offset = 0;
        var main_jul_lerp = 1;

        var presets_colormethods = {
            "terraced": {
                "id": 0
            },
            "smooth": {
                "id": 1
            },
            "interior": {
                "id": 2
            },
            "rings": {
                "id": 3
            },
            "stripes": {
                "id": 4
            }
        };

        var presets_colormaps = {
            "classic": {
                "id": 0
            },
            "ultra fractal": {
                "id": 1
            },
            "red and blue": {
                "id": 2
            }
        };

        var presets_fractals = {
            "mandelbrot": {
                "id": 0,
                "radius": 10000000
            },
            "burning ship": {
                "id": 1,
                "radius": 10000000
            },
            "celtic": {
                "id": 2,
                "radius": 10000000
            },
            "tricorn": {
                "id": 3,
                "radius": 10000000
            },
            "duck": {
                "id": 4,
                "radius": 10000000
            },
            "butt": {
                "id": 5,
                "radius": 10000000
            },
            "sine": {
                "id": 6,
                "radius": 100
            },
            "popcorn": {
                "id": 7,
                "radius": 2
            },
            "thorn": {
                "id": 8,
                "radius": 10000000
            },
            "tan mandelbrot": {
                "id": 9,
                "radius": 1.5
            },
            "henon": {
                "id": 10,
                "radius": 20000
            },
            "duffing": {
                "id": 11,
                "radius": 200
            },
            "chirikov": {
                "id": 12,
                "radius": 3
            },
            "ikeda": {
                "id": 13,
                "radius": 20000
            },
            "feather": {
                "id": 14,
                "radius": 100
            },
            "heart": {
                "id": 15,
                "radius": 10000000
            },
            "ass 2": {
                "id": 16,
                "radius": 10000000
            },
            "triangle": {
                "id": 17,
                "radius": 10000000
            }
        }

        function updateSize(size) {
            canvasMain.width = canvasMain.height = size;
            canvasJul.width = canvasJul.height = size;
            programMain = loadShaders(glmain);
            programJul = loadShaders(gljul);
            drawMain();
            drawJul();
        }

        function updateSettings() {
            radius = parseFloat(document.getElementById("radius").value);
            max_iterations = parseInt(document.getElementById("iterations").value);
            julia_constant[0] = parseFloat(document.getElementById("constantRe").value);
            julia_constant[1] = parseFloat(document.getElementById("constantIm").value);
            color_offset = parseFloat(document.getElementById("coloroffset").value);
            main_jul_lerp = parseFloat(document.getElementById("nji").value);

            drawMain();
            drawJul();
        }

        function setFractal(type) {
            fractal_type = presets_fractals[type]["id"];
            radius = presets_fractals[type]["radius"];
            document.getElementById("radius").value = radius;
            drawMain();
            drawJul();
        }

        function setColormap(name) {
            colorscheme = presets_colormaps[name]["id"];
            drawMain();
            drawJul();
        }

        function setColormethod(name) {
            color_method = presets_colormethods[name]["id"];
            drawMain();
            drawJul();
        }

        function drawMain() {
            create_url_params();
            uniform(glmain, programMain,
                [canvasMain.clientWidth, canvasMain.clientHeight],
                [center_x_main, center_y_main],
                [0, 0],
                scale_factor_main,
                radius,
                0,
                max_iterations,
                fractal_type,
                colorscheme,
                color_offset,
                color_method,
                main_jul_lerp
            );

            glmain.drawArrays(glmain.TRIANGLE_FAN, 0, 4);
        }

        function drawJul() {
            create_url_params();
            uniform(gljul, programJul,
                [canvasJul.clientWidth, canvasJul.clientHeight],
                [center_x_jul, center_y_jul],
                julia_constant,
                scale_factor_jul,
                radius,
                1,
                max_iterations,
                fractal_type,
                colorscheme,
                color_offset,
                color_method,
                main_jul_lerp
            );

            gljul.drawArrays(gljul.TRIANGLE_FAN, 0, 4);
        }

        var center_x_main = 0;
        var center_y_main = 0;
        var scale_factor_main = 1 / 2.5;
        var mouse_x_main = 0;
        var mouse_y_main = 0;
        var mouse_clicked_main = false;
        var mouse_moved_main = false;
        function updateMouseCoords_main(e) {
            mouse_x_main = (2 * (e.pageX - e.target.offsetLeft) - canvasMain.clientWidth ) / Math.min(canvasMain.clientWidth, canvasMain.clientHeight);
            mouse_y_main = (2 * (e.pageY - e.target.offsetTop ) - canvasMain.clientHeight) / Math.min(canvasMain.clientWidth, canvasMain.clientHeight);
            mouse_y_main *= -1;
            mouse_x_main = mouse_x_main / scale_factor_main + center_x_main;
            mouse_y_main = mouse_y_main / scale_factor_main + center_y_main;
        }
        function on_zoom_main(e) {
            e.preventDefault();
            var zoom = Math.exp(-e.deltaY / 500);
            updateMouseCoords_main(e);
            center_x_main = mouse_x_main + (center_x_main - mouse_x_main) / zoom;
            center_y_main = mouse_y_main + (center_y_main - mouse_y_main) / zoom;
            scale_factor_main *= zoom;
            drawMain();
        }
        function mouse_down_main(e) {
            if (e.button == 0) {
                mouse_clicked_main = true;
                mouse_moved_main = false;
            }
            updateMouseCoords_main(e);
        }
        function mouse_up_main(e) {
            mouse_clicked_main = false;
            if (e.button == 0 && !mouse_moved_main) {
                updateMouseCoords_main(e);
                julia_constant[0] = mouse_x_main;
                julia_constant[1] = mouse_y_main;
                document.getElementById("constantRe").value = mouse_x_main;
                document.getElementById("constantIm").value = mouse_y_main;
                drawJul();
            }
        }
        function mouse_move_main(e) {
            if (mouse_clicked_main) {
                mouse_moved_main = true;
                var old_x = mouse_x_main;
                var old_y = mouse_y_main;
                updateMouseCoords_main(e);
                center_x_main += old_x - mouse_x_main;
                center_y_main += old_y - mouse_y_main;
                updateMouseCoords_main(e);
                drawMain();
            }
        }

        var center_x_jul = 0;
        var center_y_jul = 0;
        var scale_factor_jul = 1 / 2.5;
        var mouse_x_jul = 0;
        var mouse_y_jul = 0;
        var mouse_clicked_jul = false;
        var mouse_moved_jul = false;
        function updateMouseCoords_jul(e) {
            mouse_x_jul = (2 * (e.pageX - e.target.offsetLeft) - canvasJul.clientWidth ) / Math.min(canvasJul.clientWidth, canvasJul.clientHeight);
            mouse_y_jul = (2 * (e.pageY - e.target.offsetTop ) - canvasJul.clientHeight) / Math.min(canvasJul.clientWidth, canvasJul.clientHeight);
            mouse_y_jul *= -1;
            mouse_x_jul = mouse_x_jul / scale_factor_jul + center_x_jul;
            mouse_y_jul = mouse_y_jul / scale_factor_jul + center_y_jul;
        }
        function on_zoom_jul(e) {
            e.preventDefault();
            var zoom = Math.exp(-e.deltaY / 500);
            updateMouseCoords_jul(e);
            center_x_jul = mouse_x_jul + (center_x_jul - mouse_x_jul) / zoom;
            center_y_jul = mouse_y_jul + (center_y_jul - mouse_y_jul) / zoom;
            scale_factor_jul *= zoom;
            drawJul();
        }
        function mouse_down_jul(e) {
            if (e.button == 0) {
                mouse_clicked_jul = true;
                mouse_moved_jul = false;
            }
            updateMouseCoords_jul(e);
        }
        function mouse_up_jul(e) {
            mouse_clicked_jul = false;
        }
        function mouse_move_jul(e) {
            if (mouse_clicked_jul) {
                mouse_moved_jul = true;
                var old_x = mouse_x_jul;
                var old_y = mouse_y_jul;
                updateMouseCoords_jul(e);
                center_x_jul += old_x - mouse_x_jul;
                center_y_jul += old_y - mouse_y_jul;
                updateMouseCoords_jul(e);
                drawJul();
            }
        }

        function create_url_params() {
            var url = new URL("https://davidsaltacc.github.io/pages/generative-art/fractals");
            var params = url.searchParams;
            params.append("cxm", center_x_main);
            params.append("cym", center_y_main);
            params.append("cxj", center_x_jul);
            params.append("cyj", center_y_jul);
            params.append("cx", julia_constant[0]);
            params.append("cy", julia_constant[1]);
            params.append("scm", scale_factor_main);
            params.append("scj", scale_factor_jul);
            params.append("r", radius);
            params.append("i", max_iterations);
            params.append("cm", color_method);
            params.append("cs", colorscheme);
            params.append("co", color_offset);
            params.append("f", fractal_type);
            params.append("nji", main_jul_lerp);
            document.getElementById("url").innerText = document.getElementById("url").href = url.href;
        }

        function apply_url_params() {
            var params = (new URL(window.location.href)).searchParams;
            center_x_main = parseFloat(params.get("cxm") ?? center_x_main);
            center_y_main = parseFloat(params.get("cym") ?? center_y_main);
            center_x_jul = parseFloat(params.get("cxj") ?? center_x_jul);
            center_y_jul = parseFloat(params.get("cyj") ?? center_y_jul);
            julia_constant[0] = parseFloat(params.get("cx") ?? julia_constant[0]);
            julia_constant[1] = parseFloat(params.get("cy") ?? julia_constant[1]);
            scale_factor_main = parseFloat(params.get("scm") ?? scale_factor_main);
            scale_factor_jul = parseFloat(params.get("scj") ?? scale_factor_jul);
            radius = parseInt(params.get("r") ?? radius);
            max_iterations = parseInt(params.get("i") ?? max_iterations);
            color_method = parseInt(params.get("cm") ?? color_method);
            colorscheme = parseInt(params.get("cs") ?? colorscheme);
            color_offset = parseFloat(params.get("co") ?? color_offset);
            fractal_type = parseInt(params.get("f") ?? fractal_type);
            main_jul_lerp = parseFloat(params.get("nji") ?? main_jul_lerp);

            document.getElementById("radius").value = radius;
            document.getElementById("iterations").value = max_iterations;
            document.getElementById("constantRe").value = julia_constant[0];
            document.getElementById("constantIm").value = julia_constant[1];
            document.getElementById("coloroffset").value = color_offset;
            document.getElementById("nji").value = main_jul_lerp;
        }

        canvasMain.onwheel = on_zoom_main;
        canvasMain.onmousedown = mouse_down_main;
        canvasMain.onmouseup = mouse_up_main;
        canvasMain.onmousemove = mouse_move_main;
        
        canvasJul.onwheel = on_zoom_jul;
        canvasJul.onmousedown = mouse_down_jul;
        canvasJul.onmouseup = mouse_up_jul;
        canvasJul.onmousemove = mouse_move_jul;

        apply_url_params();
        drawMain();
        drawJul();

    </script>
</body>
</html>