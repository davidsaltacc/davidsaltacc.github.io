<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Fractals</title>
    <link rel="stylesheet" href="../../styles.css">
    <meta property="og:type" content="website">
    <meta property="og:title" content="Fractals">
    <meta property="og:description" content="A fractal explorer">
    <meta property="og:image" content="/assets/thumbnail_fractals.html.png">
    <meta property="og:url" content="https://davidsaltacc.github.io/pages/generative-art/fractals">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Fractals">
    <meta name="twitter:description" content="A fractal explorer">
    <meta name="twitter:image" content="/assets/thumbnail_fractals.html.png">
    <link rel="shortcut icon" type="image/png" href="../../assets/favicon.png">
    <style>
        * {
            border-radius: 2px;
            border-style: none;
        }
        body {
            margin: 0;
            padding: 0;
        }
        p {
            margin: 1px;
        }
        .container {
            max-width: 98%;
        }
        input {
            width: 50%;
        }
        #constantRe, #constantIm {
            width: 25%;
        }
        #url {
            word-wrap: break-word;
        }
        #unsupported {
            display: none;
            position: fixed;
            z-index: 99;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
        }
        #statusbar {
            color: crimson;
        }
        #canvasMain, #canvasJul {
            float: right;
            top: 0;
            border-radius: 8px;
            margin-right: 4px;
        }
        #canvasMain {
            margin-left: 10px;
        }
        .sticky {
            position: -webkit-sticky; 
            position: sticky;
        }
        #title {
            font-size: 40px;
        }
        #stickycanvases {
            width: 15px;
            height: 15px;
        }
    </style>
</head>
    <div id="unsupported">
        <h1>You have been detected as a mobile user. Sadly, this website can only be viewed on Desktop browsers.</h1>
    </div>
    <div class="container">
        <br>
        <h1 id="title">David's Fractal Explorer</h1>
        <br>
        <h1 id="statusbar">Compiling Shaders. This might take a second...</h1>       
        <h3>Fractal description:</h3>
        <p id="description"></p>
        <h3>Color method description:</h3>
        <p id="description_colormethod"></p>
        <h3>Color scheme description:</h3>
        <p id="description_colorscheme"></p>
        <h3>Formula:</h3>
        <p id="formula"></p>
        <br><br>
        <h3>Fractal Selection:</h3>
        <button onclick="setFractal('mandelbrot')">Mandelbrot</button>
        <button onclick="setFractal('burning ship')">Burning ship</button>
        <button onclick="setFractal('celtic')">Celtic</button>
        <button onclick="setFractal('buffalo')">Buffalo</button>
        <button onclick="setFractal('tricorn')">Tricorn</button>
        <button onclick="setFractal('duck')">Duck</button>
        <button onclick="setFractal('ass')">B fractal</button>
        <button onclick="setFractal('sine')">Sine</button>
        <button onclick="setFractal('popcorn')">Popcorn</button>
        <button onclick="setFractal('thorn')">Thorn</button>
        <button onclick="setFractal('henon')">Henon</button>
        <button onclick="setFractal('duffing')">Duffing</button>
        <button onclick="setFractal('chirikov')">Chirikov</button>
        <button onclick="setFractal('ikeda')">Ikeda</button>
        <button onclick="setFractal('feather')">Feather</button>
        <button onclick="setFractal('heart')">Heart</button>
        <button onclick="setFractal('ass 2')">Sunglasses</button>
        <button onclick="setFractal('triangle')">Triangle</button>
        <button onclick="setFractal('shark fin')">Shark fin</button>
        <button onclick="setFractal('tippets')">Tippets</button>
        <button onclick="setFractal('zubiet')">Zubiet</button>
        <button onclick="setFractal('sinh')">Hyperbolic sine</button>
        <button onclick="setFractal('unnamed 1')">Unnamed 1</button>
        <button onclick="setFractal('unnamed 2')">Unnamed 2</button>
        <h3>Mandelbrot Power:</h3>
        <p>Float slider:</p>
        <input type="range" id="powerfloat" value="2" min="-10" max="10" step="0.001" oninput="updatePowerFloat();">
        <p>Integer slider:</p>
        <input type="range" id="powerint" value="2" min="-10" max="10" step="1" oninput="updatePowerInt();">
        <h3>After fractal function:</h3>
        <button onclick="update_post_function('none')">None</button>
        <button onclick="update_post_function('sin')">Sine</button>
        <button onclick="update_post_function('sinh')">Hyperbolic sine</button>
        <button onclick="update_post_function('cos')">Cosine</button>
        <button onclick="update_post_function('cosh')">Hyperbolic cosine</button>
        <button onclick="update_post_function('tan')">Tangent</button>
        <button onclick="update_post_function('tanh')">Hyperbolic tangent</button>
        <button onclick="update_post_function('log')">Logarithm</button>
        <button onclick="update_post_function('sqrt')">Square root</button>
        <button onclick="update_post_function('abs')">Absolute</button>
        <h3>Colormap Selection:</h3>
        <button onclick="setColormap('classic')">Classic</button>
        <button onclick="setColormap('ultra fractal')">Ultra Fractal Default</button>
        <button onclick="setColormap('red and blue')">Red and Blue</button>
        <button onclick="setColormap('sand')">Sand</button>
        <button onclick="setColormap('rainbow')">Rainbow</button>
        <p>Color offset:</p>
        <input type="range" min="0" max="1" step="0.001" value="0" id="coloroffset" oninput="updateSettings();">
        <h3>Color Method Selection:</h3>
        <button onclick="setColormethod('terraced')">Terraced</button>
        <button onclick="setColormethod('smooth')">Smooth</button>
        <button onclick="setColormethod('rings')">Rings</button>
        <button onclick="setColormethod('stripes')">Stripes</button>
        <button onclick="setColormethod('interior')">Interior</button>
        <button onclick="setColormethod('accurate')">Accurate</button>
        <h3>Controls:</h3>
        <p>Drag around the canvases with the right mouse button pressed to move</p>
        <p>Use the scroll wheel to zoom</p>
        <p>Click or drag the left mouse button on the main (first) canvas, to render the juliasets for that mouse position</p> 
        <h3>Settings:</h3>
        <p>Sticky canvases:</p>
        <input type="checkbox" id="stickycanvases" checked="true" onchange="setCanvasesSticky(document.getElementById('stickycanvases').checked);">
        <p>Escape Radius:</p>
        <input type="number" id="radius" value="2" onchange="updateSettings();">
        <p>Iterations:</p>
        <input type="number" id="iterations" value="200" onchange="updateSettings();">
        <p>Canvas Size:</p>
        <input type="number" id="size" value="500" onchange="updateSize(parseInt(document.getElementById('size').value));">
        <p>Juliaset Constant:</p>
        <input type="number" id="constantRe" value="0" onchange="updateSettings();">
        <input type="number" id="constantIm" value="0" onchange="updateSettings();">
        <p>Interpolate between normal and juliaset:</p>
        <input type="range" id="nji" value="1" min="0" max="1" step="0.001" oninput="updateSettings();">
        <h3>Save Settings:</h3>
        <a id="url" href="">_</a><br>
        <button onclick="exportMain()">Export Main as PNG</button>
        <button onclick="exportJul()">Export Juliaset as PNG</button>
        <h3>Reset Settings:</h3>
        <a href="fractals">Click here</a>
        <h3>Other Versions:</h3>
        <a href="https://davidsaltacc.github.io/pages/generative-art/fractals-old">Old Version</a><br>
        <a href="https://turbowarp.org/907856776?fps=60&turbo">Scratch Version I made for some reason</a>
        <h3>Side Note:</h3>
        <p>This project is still very early in development. This means, new features will be added in the future. Until everything is finished, bugs might occur, things might break. If you find anything, please <a href="https://github.com/davidsaltacc/davidsaltacc.github.io/issues/new">open a issue on github.</a></p>
        <h3>What are fractals and what is this?</h3>
        <a href="https://en.wikipedia.org/wiki/Fractal">https://en.wikipedia.org/wiki/Fractal</a><br>
        <a href="https://en.wikipedia.org/wiki/Mandelbrot_set">https://en.wikipedia.org/wiki/Mandelbrot_set</a><br>
        <a href="https://en.wikipedia.org/wiki/Julia_set">https://en.wikipedia.org/wiki/Julia_set</a><br>
        <a href="https://blinry.org/mandelbrot/">https://blinry.org/mandelbrot</a><br>
        <a href="https://alonso-delarte.medium.com/a-quick-explanation-of-the-mandelbrot-set-41102d7182b">https://alonso-delarte.medium.com/a-quick-explanation-of-the-mandelbrot-set-41102d7182b</a><br>
        <a href="http://www.paulbourke.net/fractals/">http://www.paulbourke.net/fractals/</a>
        <h3>Special Thanks:</h3>
        <p><a href="https://nathansolomon1678.github.io/fractals">This</a> project by nathansolomon1678 on github, where I got a lot of insipration (and maybe code ;) from</p>
        <p>Paul Bourke, especially their website page on fractals <a href="http://www.paulbourke.net/fractals/">here</a>, where I got lots of the fractals and insipration from</p>
        <p>CodeParade (HackerPoet on github) for <a href="https://github.com/HackerPoet/FractalSoundExplorer">this</a> project, where I got the code for the feather fractal from</p>
        <p>All the amazing people who discovered all of these fractals and made this project possible</p>
        <p>My friends (they did nothing for this project but still thanks)</p>
        <p>You, for visiting and testing my project!</p>
        <h3>TODO for me</h3>
        <p>add explanation (important), add more fractals, add more colormaps, a transition effect, when switching fractal types (lerp?), add presets<p>
        <h3>View Fractal Gallery:</h3>
        <a href="https://davidsaltacc.github.io/pages/gallery/fractals">Fractal Gallery</a>
    </div>
    <script type="x-shader/x-vertex" id="vert-shader">#version 300 es
        #ifdef GL_FRAGMENT_PRECISION_HIGH
            precision highp float;
        #else
            precision mediump float;
        #endif
        in vec2 position;
        out vec2 vertex_position;
        void main() {
            gl_Position = vec4(position, 0., 1.);
            vertex_position = position;
        }
    </script>
    <script type="x-shader/x-fragment" id="frag-shader">#version 300 es
        #ifdef GL_FRAGMENT_PRECISION_HIGH
            precision highp float;
        #else
            precision mediump float;
        #endif
        in vec2 vertex_position;
        out vec4 fragmentColor;

        uniform vec2 canvas_dimensions;
        uniform vec2 center;
        uniform vec2 julia_constant;
        uniform float scale_factor;
        uniform float radius;
        uniform int juliaset;
        uniform int max_iterations;
        uniform int fractal_type;
        uniform int colorscheme;
        uniform float color_offset;
        uniform int color_method;
        uniform float main_juliaset_lerp;
        uniform float mandelbrot_power;
        uniform int post_function;

        #define pi 3.141592653589793
        #define e 2.718281828459045

        float square(float x) {
            return x * x;
        }
        float magnitude(vec2 z) {
            return sqrt(square(z.x) + square(z.y));
        }
        float power(float n, float p) {
            if (p == 1.) {
                return n;
            }
            if (p == 2.) {
                return n * n;
            }
            return pow(n, p);
        }

        vec2 c_multiplication(vec2 a, vec2 b) {
            return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);
        }
        vec2 c_division(vec2 a, vec2 b) {
            return vec2(((a.x * b.x + a.y * b.y) / (b.x * b.x + b.y * b.y)), ((a.y * b.x - a.x * b.y) / (b.x * b.x + b.y * b.y)));
        }
        vec2 c_sin(vec2 z) {
            return vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y));
        }
        vec2 c_sinh(vec2 z) {
            return vec2(sinh(z.x) * cos(z.y), cosh(z.x) * sin(z.y)); 
        }
        vec2 c_cos(vec2 z) {
            return vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y));
        }
        vec2 c_cosh(vec2 z) {
            return vec2(cosh(z.x) * cos(z.y), sinh(z.x) * sin(z.y)); 
        }
        vec2 c_tan(vec2 z) {
            float cosx = cos(z.x);
            float sinx = sin(z.x);
            float sinhy = sinh(z.y);
            float coshy = cosh(z.y);
            float d = (cosx * coshy - sinx * sinhy);
            float re = (sinx * coshy) / d;
            float im = (cosx * sinhy) / d;
            return vec2(re, im);
        }
        vec2 c_tanh(vec2 z) {
            return c_division(c_sinh(z), c_cosh(z));
        }
        vec2 c_log(vec2 z) {
            float re = sqrt((z.x * z.x) + (z.y * z.y));
            float im = atan(z.y, z.x);
            if (im > pi) {
                im = im - (2. * pi);
            }
            return vec2(log(re), im);
        }
        vec2 c_sqrt(vec2 z) {
            float r = length(z);
            float re = sqrt(0.5 * (r + z.x));
            float im = sqrt(0.5 * (r - z.x));
            if (z.y < 0.) {
                im = -im;
            }
            return vec2(re, im);
        }
        vec2 c_abs(vec2 z) {
            return vec2(abs(z.x), abs(z.y));
        }
        
        vec2 to_polar(vec2 z) {
            float r = length(z);
            float theta = atan(z.y, z.x);
            return vec2(r, theta);
        }
        vec2 mand_power(vec2 z, float n) {
            vec2 polar = to_polar(z);
            float r = pow(polar.x, n);
            float theta = n * polar.y;
            return r * vec2(cos(theta), sin(theta));
        }

        float weierstrass(float x) {
            x *= 2.;
            return cos(x) + cos(3. * x) / 2. + cos(9. * x) / 4. + cos(27. * x) / 8. + cos(81. * x) / 16.;
        }

        float cubic_interpolation(float a, float b, float c, float d, float x) {
            return b +
                   x * (.5 * c - .5 * a) +
                   x * x * (a - 2.5 * b + 2. * c - .5 * d) +
                   x * x * x * (-.5 * a + 1.5 * b - 1.5 * c + .5 * d);
        }

        vec4 color_interpolate(vec3 color0, vec3 color1, vec3 color2, vec3 color3, float x) {
            return vec4(
                cubic_interpolation(color0.r, color1.r, color2.r, color3.r, x),
                cubic_interpolation(color0.g, color1.g, color2.g, color3.g, x),
                cubic_interpolation(color0.b, color1.b, color2.b, color3.b, x),
                1.
            );
        }

        vec4 classic_colorscheme(float x) {
            x *= pi * 2.;
            return vec4(
                .5 + sin(x) / 2.,
                .5 + sin(x + 1.) / 2.,
                .5 + sin(x + 2.) / 2.,
                1.
            );
        }

        vec4 ultrafractal_colorscheme(float x) {
            vec3 blue      = vec3(0., 0.03, 0.39);
            vec3 lightblue = vec3(0.12, 0.42, 0.8);
            vec3 white     = vec3(0.93, 1., 1.);
            vec3 orange    = vec3(1., 0.66, 0.);
            vec3 black     = vec3(0., 0.1, 0.007);
            x = fract(x) * 5.;
            if (x < 1.) {
                return color_interpolate(blue, lightblue, white, orange, fract(x));
            }
            if (x < 2.) {
                return color_interpolate(lightblue, white, orange, black, fract(x));
            }
            if (x < 3.) {
                return color_interpolate(white, orange, black, blue, fract(x));
            }
            if (x < 4.) {
                return color_interpolate(orange, black, blue, lightblue, fract(x));
            }
            if (x < 5.) {
                return color_interpolate(black, blue, lightblue, white, fract(x));
            }
            return vec4(black, 1.);
        }

        vec4 red_blue_colorscheme(float x) {
            vec3 red   = vec3(1., .3, 0.);
            vec3 white = vec3(1., 1., 1.);
            vec3 blue  = vec3(0.2, 0.4, 1.);
            vec3 black = vec3(0., 0., 0.);
            x = fract(x) * 4.;
            if (x < 1.) {
                return color_interpolate(black, red, white, blue, fract(x));
            }
            if (x < 2.) {
                return color_interpolate(red, white, blue, black, fract(x));
            }
            if (x < 3.) {
                return color_interpolate(white, blue, black, red, fract(x));
            }
            if (x < 4.) {
                return color_interpolate(blue, black, red, white, fract(x));
            }
            return vec4(black, 1.);
        }

        vec4 sand_colorscheme(float x) {
            vec3 yellow = vec3(0.97, 0.91, 0.69);
            vec3 orange = vec3(0.88, 0.57, 0.39);
            vec3 cyan   = vec3(0.34, 0.6,  0.58);
            vec3 blue   = vec3(0.27, 0.32, 0.39);
            x = fract(x) * 4.;
            if (x < 1.) {
                return color_interpolate(blue, yellow, orange, cyan, fract(x));
            }
            if (x < 2.) {
                return color_interpolate(yellow, orange, cyan, blue, fract(x));
            }
            if (x < 3.) {
                return color_interpolate(orange, cyan, blue, yellow, fract(x));
            }
            if (x < 4.) {
                return color_interpolate(cyan, blue, yellow, orange, fract(x));
            }
            return vec4(0., 0., 0., 1.);
        }

        vec4 rainbow_colorscheme(float x) {
            vec3 red       = vec3(1., 0., 0.);
            vec3 yellow    = vec3(1., 1., 0.);
            vec3 green     = vec3(0., 1., 0.);
            vec3 lightblue = vec3(0., 1., 1.);
            vec3 blue      = vec3(0., 0., 1.);
            vec3 pink      = vec3(1., 0., 1.);
            x = fract(x) * 6.;
            if (x < 1.) {
                return color_interpolate(pink, red, yellow, green, fract(x));
            }
            if (x < 2.) {
                return color_interpolate(red, yellow, green, lightblue, fract(x));
            }
            if (x < 3.) {
                return color_interpolate(yellow, green, lightblue, blue, fract(x));
            }
            if (x < 4.) {
                return color_interpolate(green, lightblue, blue, pink, fract(x));
            }
            if (x < 5.) {
                return color_interpolate(lightblue, blue, pink, red, fract(x));
            }
            if (x < 6.) {
                return color_interpolate(blue, pink, red, yellow, fract(x));
            }
            return vec4(0., 0., 0., 1.);
        }

        vec4 color(float x) {
            x += color_offset;
            if (colorscheme == 0) {
                return classic_colorscheme(x);
            }
            if (colorscheme == 1) {
                return ultrafractal_colorscheme(x);
            } 
            if (colorscheme == 2) {
                return red_blue_colorscheme(x);
            }
            if (colorscheme == 3) {
                return sand_colorscheme(x);
            }
            if (colorscheme == 4) {
                return rainbow_colorscheme(x);
            }
        }

        vec2 apply_post_function(vec2 z) {
            if (post_function == 0) {
                return z;
            }
            if (post_function == 1) {
                return c_sin(z);
            }
            if (post_function == 2) {
                return c_sinh(z);
            }
            if (post_function == 3) {
                return c_cos(z);
            }
            if (post_function == 4) {
                return c_cosh(z);
            }
            if (post_function == 5) {
                return c_tan(z);
            }
            if (post_function == 6) {
                return c_tanh(z);
            }
            if (post_function == 7) {
                return c_log(z);
            }
            if (post_function == 8) {
                return c_sqrt(z);
            }
            if (post_function == 9) {
                return c_abs(z);
            }
        }

        vec2 iteration(vec2 z, vec2 c, int type) {
            if (type == 0) {
                // Mandelbrot
                return c + apply_post_function(mand_power(z, mandelbrot_power));
            } 
            if (type == 1) {
                // Burning ship
                vec2 power = mand_power(z, mandelbrot_power);
                return c + apply_post_function(vec2(power.x, abs(power.y)));
            }
            if (type == 2) {
                // Celtic
                vec2 power = mand_power(z, mandelbrot_power);
                return c + apply_post_function(vec2(abs(power.x), power.y));
            }
            if (type == 3) {
                // Buffalo
                vec2 power = mand_power(z, mandelbrot_power);
                return c + apply_post_function(vec2(abs(power.x), abs(power.y)));
            }
            if (type == 4) {
                // Tricorn
                vec2 power = mand_power(z, mandelbrot_power);
                return c + apply_post_function(vec2(power.x, -power.y));
            }
            if (type == 5) {
                // Duck
                // own custom polar coordinate formula, because it needs to be modified
                vec2 polar = to_polar(z);
                float r = pow(polar.x, mandelbrot_power);
                float theta = mandelbrot_power * abs(polar.y);
                return c + apply_post_function(r * vec2(cos(theta), sin(theta)));
            }
            if (type == 6) {
                // Butt
                return c + apply_post_function(vec2(z.x * z.x * z.x - z.y * z.y * abs(z.y), 2. * z.x * z.y));
            }
            if (type == 7) {
                // Juliaset Sine (very high radius required)
                return apply_post_function(c * c_sin(z));
            }
            if (type == 8) {
                // Popcorn (ideal radius ca ~2)
                return apply_post_function(vec2(z.x - c.x * (z.y + tan(3. * z.y)), z.y - c.y * (z.x + tan(3. * z.x))));
            }
            if (type == 9) {
                // Thorn (very high radius required)
                return apply_post_function(vec2(z.x / cos(z.y), z.y / sin(z.x))) + c;
            }
            if (type == 10) {
                // Henon (radius rather high, ~20000)
                return apply_post_function(vec2(1. - c.x * z.x * z.x + z.y, c.y * z.x));
            }
            if (type == 11) {
                // Duffing (radius not too important, ~200)
                return apply_post_function(vec2(z.y, -1. * c.y * z.x + c.x * z.y - z.y * z.y * z.y));
            }
            if (type == 12) {
                // Chirikov (low radius, ~3)
                return apply_post_function(vec2(z.x + c.x * z.y, c.y + c.y * sin(z.x)));
            }
            if (type == 13) {
                // Ikeda (radius rather high, ~20000)
                float t = 0.4 - 6. / (1. + square(z.x) + square(z.y));
                float sin_t = sin(t);
                float cos_t = cos(t);
                return apply_post_function(vec2(1. + c.x * (z.x * cos_t - z.y * sin_t), c.y * (z.x * sin_t + z.y * cos_t)));
            }
            if (type == 14) {
                // Feather (radius around ~200 or lower)
                float dr = 1. + z.x * z.x;
                float di = z.y * z.y;
                vec2 p = mand_power(z, 3.);
                float zr = p.x;
                float zi = p.y;
                float dvr = (zr * dr + zi * di) / (dr * dr + di * di);
                float dvi = (zi * dr - zr * di) / (dr * dr + di * di);
                return apply_post_function(vec2(dvr, dvi)) + c;
            }
            if (type == 15) {
                // Heart
                return vec2(c.x, c.y * -1.) + apply_post_function(vec2(2. * z.x * z.y, abs(z.y) - abs(z.x)));
            }
            if (type == 16) {
                // Ass 2
                return c + apply_post_function(vec2(sinh(z.x) * sin(z.y), cosh(z.y) * cos(z.x)));
            }
            if (type == 17) {
                // Triangle
                return c + apply_post_function(vec2(sin(z.x) * sinh(z.y), cos(z.y) * cosh(z.x)));
            }
            if (type == 18) {
                // Shark fin
                return c + apply_post_function(vec2(z.x * z.x - abs(z.y) * z.y, z.x * z.y * 2.));
            }
            if (type == 19) {
                // Tippets
                float re = z.x * z.x - z.y * z.y + c.x;
                float im = 2. * re * z.y + c.y;
                return apply_post_function(vec2(re, im));
            }
            if (type == 20) {
                // Zubiet
                return apply_post_function(mand_power(z, mandelbrot_power)) + c_division(c, z);
            }
            if (type == 21) {
                // Sinh julia
                return apply_post_function(mand_power(c_sinh(z), float(mandelbrot_power))) + c;
            }
            if (type == 22) {
                // Unnamed 1
                return apply_post_function(mand_power(z, mandelbrot_power) - mand_power(-z, c.x) + vec2(c.y, 0.));
            }
            if (type == 23) {
                // Unnamed 2
                return apply_post_function(mand_power(z - c_division(mand_power(z, 3.) - vec2(1., 0.), 3. * mand_power(z, 2.)), mandelbrot_power)) + c;
            }
        }

        void main() {
            vec2 window = canvas_dimensions / min(canvas_dimensions.x, canvas_dimensions.y);
            vec2 original_z = vertex_position * window / scale_factor + center;
            original_z = vec2(original_z.x, original_z.y * -1.); // its upside down somehow?
            vec2 last_z = original_z;
            vec2 z = original_z;
            vec2 c = original_z;
            if (juliaset == 1) {
                if (main_juliaset_lerp == 1.) {
                    c = vec2(julia_constant.x, julia_constant.y * -1.); // it gets inverted for some reason;
                } else if (main_juliaset_lerp == 0.) {
                    c = original_z;
                } else {
                    c = (1. - main_juliaset_lerp) * original_z + main_juliaset_lerp * vec2(julia_constant.x, julia_constant.y * -1.);;
                }
            }
            float distance_to_orbit_trap = 100000000.;
            float color_v = 0.;
            bool color_black = false;
            float stripe = 0.;
            
            for (int i = 0; i <= max_iterations; i++) {
                z = iteration(z, c, fractal_type);
                if (color_method == 0) {
                    if (magnitude(z) > radius) {
                        color_v = float(i) / float(max_iterations);
                        break;
                    } else if (i == max_iterations) {
                        color_black = true;
                    }
                } else if (color_method == 1) {
                    if (magnitude(z) > radius) {
                        float float_iters = float(i) + log(radius / magnitude(last_z)) / log(magnitude(z) / magnitude(last_z));
                        color_v = float_iters / float(max_iterations);
                        break;
                    } else if (i == max_iterations) {
                        color_black = true;
                    }
                } else if (color_method == 2) {
                    if (magnitude(z) > radius) {
                        color_black = true;
                        break;
                    } else {
                        color_v = log(magnitude(z));
                    }
                } else if (color_method == 3) {
                    distance_to_orbit_trap = min(distance_to_orbit_trap, abs(magnitude(z) - radius));
                    color_v = -log(log(distance_to_orbit_trap));
                } else if (color_method == 4) {
                    if (magnitude(z) > radius) {
                        float float_iters = float(i) + log(radius / magnitude(last_z)) / log(magnitude(z) / magnitude(last_z));
                        stripe += weierstrass(atan(z.y, z.x)) * fract(float_iters);
                        color_v = float_iters / square(log(float_iters)) + 40. * stripe / float_iters;
                        color_v /= float(max_iterations);
                        break;
                    } else if (i == max_iterations) {
                        color_black = true;
                    } else {
                        stripe += weierstrass(atan(z.y, z.x));
                    }
                } else if (color_method == 5) {
                    if (magnitude(z) > radius) {
                        color_v = 0.;
                        break;
                    } else if (i == max_iterations) {
                        color_black = true;
                    }
                }
                last_z = z;
            }
            if (color_black) {
                fragmentColor = vec4(0., 0., 0., 1.);
            } else {
                fragmentColor = color(color_v);
            }
        }
    </script>
    <script>
        function unsupported_device() {
            let check = false;
            (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))) check = true;})(navigator.userAgent||navigator.vendor||window.opera);
            return check;
        };

        if (unsupported_device()) {
            document.getElementById("unsupported").style.display = "block";
            
            // crash, best way to stop the rest from executing at all
            throw new Error("unsupported device detected");
        }

        var container = document.getElementsByClassName("container")[0];
        var canvasMain = document.createElement("canvas");
        var canvasJul = document.createElement("canvas");
        canvasMain.id = "canvasMain";
        canvasJul.id = "canvasJul";
        canvasMain.className = "sticky";
        canvasJul.className = "sticky";
        container.prepend(canvasMain);
        container.prepend(canvasJul);
        canvasMain.width = 500;
        canvasMain.height = 500;
        canvasJul.width = 500;
        canvasJul.height = 500;
        canvasMain.oncontextmenu = function(e) { e.preventDefault() };
        canvasJul.oncontextmenu = function(e) { e.preventDefault() };
        var glmain = canvasMain.getContext("webgl2", { preserveDrawingBuffer: true });
        var gljul = canvasJul.getContext("webgl2", { preserveDrawingBuffer: true });

        function loadShaders(gl) {
            if (!gl) {
                alert("Your browser does not support WebGL. This could also be caused by rendering a too large or resource-intensive image. If that is the case, please restart your browser.");
                return null;
            }
            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
            gl.clearColor(0., 0., 0., 1.);
            gl.clear(gl.COLOR_BUFFER_BIT);
            var source = document.getElementById("vert-shader").innerText;
            var vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, source);
            gl.compileShader(vertexShader);
            var vertShaderLog = gl.getShaderInfoLog(vertexShader);
            source = document.getElementById("frag-shader").innerText;
            var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, source);
            gl.compileShader(fragmentShader);
            var fragShaderLog = gl.getShaderInfoLog(fragmentShader);
            var program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            gl.detachShader(program, vertexShader);
            gl.detachShader(program, fragmentShader);
            gl.deleteShader(vertexShader);
            gl.deleteShader(fragmentShader);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                alert(gl.getProgramInfoLog(program));
                console.log(vertShaderLog);
                console.log(fragShaderLog);
                return null;
            }
            var vertexArray = new Float32Array([-1., -1., 1., -1., 1., 1., -1., 1.]);
            var vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertexArray, gl.STATIC_DRAW);
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            var aVertexPosition = gl.getAttribLocation(program, "position");
            gl.enableVertexAttribArray(aVertexPosition);
            gl.vertexAttribPointer(aVertexPosition, 2, gl.FLOAT, false, 0, 0);
            gl.useProgram(program);
            return program;
        }

        var programMain = null;
        var programJul = null;

        var julia_constant = [0, 0];

        function uniform(gl, program,
            canvas_dimensions,
            center,
            julia_constant,
            scale_factor,
            radius,
            juliaset,
            max_iterations,
            fractal_type,
            colorscheme,
            color_offset,
            color_method,
            main_juliaset_lerp,
            mandelbrot_power,
            post_function
        ) {
            gl.uniform2fv(gl.getUniformLocation(program, "canvas_dimensions"), canvas_dimensions);
            gl.uniform2fv(gl.getUniformLocation(program, "center"), center);
            gl.uniform2fv(gl.getUniformLocation(program, "julia_constant"), julia_constant);
            gl.uniform1f(gl.getUniformLocation(program, "scale_factor"), scale_factor);
            gl.uniform1f(gl.getUniformLocation(program, "radius"), radius);
            gl.uniform1i(gl.getUniformLocation(program, "juliaset"), juliaset);
            gl.uniform1i(gl.getUniformLocation(program, "max_iterations"), max_iterations);
            gl.uniform1i(gl.getUniformLocation(program, "fractal_type"), fractal_type);
            gl.uniform1i(gl.getUniformLocation(program, "colorscheme"), colorscheme);
            gl.uniform1f(gl.getUniformLocation(program, "color_offset"), color_offset);
            gl.uniform1i(gl.getUniformLocation(program, "color_method"), color_method);
            gl.uniform1f(gl.getUniformLocation(program, "main_juliaset_lerp"), main_juliaset_lerp);
            gl.uniform1f(gl.getUniformLocation(program, "mandelbrot_power"), mandelbrot_power);
            gl.uniform1i(gl.getUniformLocation(program, "post_function"), post_function);
        }

        var radius = 2000000;
        var max_iterations = 200;
        var fractal_type = 0;
        var color_method = 1;
        var colorscheme = 0;
        var color_offset = 0;
        var main_jul_lerp = 1;
        var mandelbrot_power = 2;
        var power_slider_float = 0;
        var fractal_post_function = 0;

        var presets_colormethods = {
            "terraced": {
                "id": 0,
                "description": "\"Mathematically accurate\" coloring method. Not smoothed, colored based on how long it takes for z to escape to infinity."
            },
            "smooth": {
                "id": 1,
                "description": "Smooth coloring."
            },
            "interior": {
                "id": 2,
                "description": "Interior coloring."
            },
            "rings": {
                "id": 3,
                "description": "Rings around the fractal. A lower radius makes it look better sometimes. Aim for around 20000."
            },
            "stripes": {
                "id": 4,
                "description": "Really cool stripes pattern."
            },
            "accurate": {
                "id": 5,
                "description": "Pixels are either black (part of the set) or not (not a part of the set)."
            }
        };

        var presets_colormaps = {
            "classic": {
                "id": 0,
                "description": "The \"Classic\" colormap. Easily calculated with a bit of math magic."
            },
            "ultra fractal": {
                "id": 1,
                "description": "The default colormap in ultra fractal."
            },
            "red and blue": {
                "id": 2,
                "description": "Red and blue. As the name says."
            },
            "sand": {
                "id": 3,
                "description": "Sand colormap. Colors remind of sand and water related things."
            },
            "rainbow": {
                "id": 4,
                "description": "Basically a HSV colormap. Just rainbows."
            }
        };

        var presets_functions = {
            "none": {
                "id": 0,
                "radius": null
            },
            "sin": {
                "id": 1,
                "radius": 10
            },
            "sinh": {
                "id": 2,
                "radius": 10
            },
            "cos": {
                "id": 3,
                "radius": 10
            },
            "cosh": {
                "id": 4,
                "radius": 10
            },
            "tan": {
                "id": 5,
                "radius": 10
            },
            "tanh": {
                "id": 6,
                "radius": 10
            },
            "log": {
                "id": 7,
                "radius": 10
            },
            "sqrt": {
                "id": 8,
                "radius": 10
            },
            "abs": {
                "id": 9,
                "radius": 10
            }
        }

        var presets_fractals = {
            "mandelbrot": {
                "id": 0,
                "radius": 10000000,
                "formula": "z<sub>n+1</sub> = FSz<sub>n</sub><sup>POWER</sup>FE + c",
                "description": "The standard Mandelbrot set."
            },
            "burning ship": {
                "id": 1,
                "radius": 10000000,
                "formula": "z<sub>n+1</sub> = FS(Re(z<sub>n</sub>) + i*abs(Im(z<sub>n</sub>)))<sup>POWER</sup>FE + c",
                "description": "A variation of the Mandelbrot set. Got its name because of the tiny burning ship on the left."
            },
            "celtic": {
                "id": 2,
                "radius": 10000000,
                "formula": "z<sub>n+1</sub> = FS(abs(Re(z<sub>n</sub>)) + i*Im(z<sub>n</sub>))<sup>POWER</sup>FE + c",
                "description": "Another variation of the Mandelbrot set. Kind of looks like a fish."
            },
            "buffalo": {
                "id": 3,
                "radius": 10000000,
                "formula": "z<sub>n+1</sub> = FS(abs(Re(z<sub>n</sub>)) + i*abs(Im(z<sub>n</sub>)))<sup>POWER</sup>FE + c",
                "description": "Yet another Mandelbrot variation. The reason for its name should be obvious."
            },
            "tricorn": {
                "id": 4,
                "radius": 10000000,
                "formula": "z<sub>n+1</sub> = FS(Re(z<sub>n</sub>) + i*-Im(z<sub>n</sub>))<sup>POWER</sup>FE + c",
                "description": "ANOTHER Mandelbrot variation. Also called the Mandelbar sometimes."
            },
            "duck": {
                "id": 5,
                "radius": 10000000,
                "formula": "r = magnitude(z)<sup>POWER</sup><br>theta = POWER * abs(atan(z<sub>n+1</sub>))<br>z<sub>n+1</sub> = FSr * (cos(theta) + i*sin(theta))FE + c",
                "description": "Another Mandlebrot variation. Looks like a duck. Apparently also called the perpendicular burning ship. Formula is mostly just the polar coordinate formula for getting the N-th power of z, it has to be modified for the duck."
            },
            "ass": {
                "id": 6,
                "radius": 10000000,
                "formula": "z<sub>n+1</sub> = FS(Re(z<sub>n</sub>)<sup>3</sup> - Im(z<sub>n</sub>)<sup>2</sup> * abs(Re(z<sub>n</sub>)) + i*(2 * Re(z<sub>n</sub>) * Im(z<sub>n</sub>)))FE + c",
                "description": "Kind of looks like- well, ..., whatever."
            },
            "sine": {
                "id": 7,
                "radius": 100,
                "formula": "z<sub>n+1</sub> = FSc * sin(z<sub>n</sub>)FE",
                "description": "Infinitely repeating to the left and right. Interesting, isn't it?"
            },
            "popcorn": {
                "id": 8,
                "radius": 2,
                "formula": "z<sub>n+1</sub> = FS(Re(z<sub>n</sub>) - Re(c) * (Im(z<sub>n</sub>) + tan(3 * Im(z<sub>n</sub>))), Im(z<sub>n</sub>)) - Im(c) * (Re(z<sub>n</sub>) + tan(3 * Re(z<sub>n</sub>)))FE",
                "description": "I have no idea who named this one the \"Popcorn\" fractal. Maybe the creators name was Popcorn? Also, it generates really cool patterns."
            },
            "thorn": {
                "id": 9,
                "radius": 10000000,
                "formula": "z<sub>n+1</sub> = FS(Re(z<sub>n</sub>) / cos(Im(z<sub>n</sub>)), Im(z<sub>n</sub>) / sin(Re(z<sub>n</sub>)))FE + c",
                "description": "Not the usual kind of fractal, yet still very interesting."
            },
            "henon": {
                "id": 10,
                "radius": 20000,
                "formula": "z<sub>n+1</sub> = FS(1 - Re(c) * Re(z<sub>n</sub>) * Re(z<sub>n</sub>) + Im(z<sub>n</sub>) + i*(Im(c) * Re(z<sub>n</sub>)))FE",
                "description": "Henon map."
            },
            "duffing": {
                "id": 11,
                "radius": 200,
                "formula": "z<sub>n+1</sub> = FS(Im(z<sub>n</sub>) + i*(-1 * Im(c) * Re(z<sub>n</sub>) + Re(c) * Im(z<sub>n</sub>) - Im(z<sub>n</sub>)<sup>3</sup>))FE",
                "description": "Duffing map."
            },
            "chirikov": {
                "id": 12,
                "radius": 100, 
                "formula": "z<sub>n+1</sub> = FS(Re(z<sub>n</sub>) + Re(c) * Im(z<sub>n</sub>) + i*(Im(c) + Im(c) * sin(Re(z<sub>n</sub>))FE",
                "description": "Chirikov map."
            },
            "ikeda": {
                "id": 13,
                "radius": 20000,
                "formula": "t = 0.4 - 6 / (1 + Re(z<sub>n</sub>)<sup>2</sup> + Im(z<sub>n</sub>)<sup>2</sup>)<br>z<sub>n+1</sub> = FS(1 + Re(c) * (Re(z<sub>n</sub>) * cos(t) - Im(z<sub>n</sub>) * sin(t)) + i*(Im(c) * (Re(z<sub>n</sub>) * sin(t) + Im(z<sub>n</sub>) * cos(t))))FE",
                "description": "Ikeda map. Beast of a formula."
            },
            "feather": {
                "id": 14,
                "radius": 50, 
                "formula": "z<sub>n+1</sub> = FSz<sub>n</sub><sup>3</sup>/(1 + Re(z<sub>n</sub>)<sup>2</sup> + Im(z<sub>n</sub>)<sup>2</sup>)FE + c",
                "description": "Really cool looking fractal. Looks like a feather."
            },
            "heart": {
                "id": 15,
                "radius": 10000000,
                "formula": "z<sub>n+1</sub> = FS(2 * Re(z<sub>n</sub>) * Im(z<sub>n</sub>) + i*(abs(Im(z<sub>n</sub>)) - abs(Re(z<sub>n</sub>))))FE + c",
                "description": "I wonder where this one got its name from."
            },
            "ass 2": {
                "id": 16,
                "radius": 10000000,
                "formula": "z<sub>n+1</sub> = FS(sinh(Re(z<sub>n</sub>)) * sin(Im(z<sub>n</sub>)) + i*(cosh(Im(z<sub>n</sub>)) * cos(Re(z<sub>n</sub>))))FE + c",
                "description": "Looks just a little bit like sunglasses."
            },
            "triangle": {
                "id": 17,
                "radius": 10000000,
                "formula": "z<sub>n+1</sub> = FS(sin(Re(z<sub>n</sub>)) * sinh(Im(z<sub>n</sub>)) + i*(cos(Im(z<sub>n</sub>)) * cosh(Re(z<sub>n</sub>))))FE + c",
                "description": "Literally just a triangle."
            },
            "shark fin": {
                "id": 18,
                "radius": 10000000,
                "formula": "z<sub>n+1</sub> = FS(Re(z<sub>n</sub>)<sup>2</sup> - abs(Im(z<sub>n</sub>)) * Im(z<sub>n</sub>)) + i*(2 * Re(z<sub>n</sub>) * Im(z<sub>n</sub>))FE + c",
                "description": "Could also be a dolphin. Actually, not really."
            },
            "tippets": {
                "id": 19,
                "radius": 10000000,
                "formula": "re = Re(z<sub>n</sub>)<sup>2</sup> - Im(z<sub>n</sub>)<sup>2</sup> + Re(c)<br>z<sub>n+1</sub> = FS(re, i*(2 * re * Im(z<sub>n</sub>) + Im(c)))FE",
                "description": "With all respect, I think, John Tippets just messed up the code for a mandelbrot set, and got this."
            },
            "zubiet": {
                "id": 20,
                "radius": 10000000,
                "formula": "z<sub>n+1</sub> = FSz<sub>n</sub><sup>POWER</sup>FE + c / z<sub>n</sub>",
                "description": "Looks really interesting. "
            },
            "sinh": {
                "id": 21,
                "radius": 70,
                "formula": "z<sub>n+1</sub> = FSc * sinh(z<sub>n</sub>)FE",
                "description": "Kind of like the sine, this one is repeating infinitely vertically. Just looks a little better."
            },
            "unnamed 1": {
                "id": 22,
                "radius": 10000000,
                "formula": "z<sub>n+1</sub> = FSz<sub>n</sub><sup>POWER</sup> - (-z<sub>n</sub>)<sup>Re(c)</sup> + (Im(c) + 0i)",
                "description": "I found no good name for this. If you can think of anything, tell me."
            },
            "unnamed 2": {
                "id": 23,
                "radius": 10000000,
                "formula": "z<sub>n+1</sub> = FS(z<sub>n</sub> - (z<sub>n</sub><sup>3</sup> - 1) / (3 * z<sub>n</sub><sup>2</sup>))<sup>POWER</sup>FE + c",
                "description": "I found no name again. Creates really cool patterns. On a power of one (change with power slider) and interior coloring, seems to create a Nova/Newton fractal."
            }
        }

        function update_formula() {
            for (f in presets_fractals) {
                if (presets_fractals[f]["id"] == fractal_type) {
                    var func_start = "";
                    var func_end = "";
                    if (fractal_post_function != 0) {
                        for (fn in presets_functions) {
                            if (presets_functions[fn]["id"] == fractal_post_function) {
                                func_start = fn + "(";
                                func_end = ")";
                            }
                        };
                    }
                    document.getElementById("formula").innerHTML = presets_fractals[f]["formula"]
                        .replaceAll("POWER", mandelbrot_power)
                        .replace("FS", func_start)
                        .replace("FE", func_end);
                }
            };
        }

        function update_ui() {
            document.getElementById("radius").value = radius;
            document.getElementById("iterations").value = max_iterations;
            document.getElementById("constantRe").value = julia_constant[0];
            document.getElementById("constantIm").value = julia_constant[1];
            document.getElementById("coloroffset").value = color_offset;
            document.getElementById("nji").value = main_jul_lerp;

            for (f in presets_fractals) {
                if (presets_fractals[f]["id"] == fractal_type) {
                    document.getElementById("description").innerHTML = presets_fractals[f]["description"]; 
                }
            }
            for (c in presets_colormaps) {
                if (presets_colormaps[c]["id"] == colorscheme) {
                    document.getElementById("description_colorscheme").innerHTML = presets_colormaps[c]["description"]; 
                }
            }
            for (m in presets_colormethods) {
                if (presets_colormethods[m]["id"] == color_method) {
                    document.getElementById("description_colormethod").innerHTML = presets_colormethods[m]["description"]; 
                }
            }

            if (power_slider_float == 1) {
                document.getElementById("powerfloat").value = mandelbrot_power;
                document.getElementById("powerint").value = Math.round(mandelbrot_power);
            }
            if (power_slider_float == 0) {
                document.getElementById("powerint").value = mandelbrot_power;
                document.getElementById("powerfloat").value = mandelbrot_power;
            }
        }

        function setCanvasesSticky(sticky) {
            canvasMain.className = sticky ? "sticky" : "";
            canvasJul.className = sticky ? "sticky" : "";
        }

        function updateSize(size) {
            canvasMain.width = canvasMain.height = size;
            canvasJul.width = canvasJul.height = size;
            canvasMain.clientWidth = canvasMain.clientHeight = size;
            canvasJul.clientWidth = canvasJul.clientHeight = size;
            programMain = loadShaders(glmain);
            programJul = loadShaders(gljul);
            drawMain();
            drawJul();
            if (size > (window.innerWidth - window.innerWidth / 6) / 2 && size > window.innerHeight - window.innerHeight / 4) {
                setCanvasesSticky(false);
            } else {
                setCanvasesSticky(true);
            }
        }

        function update_post_function(name) {
            for (f in presets_functions) {
                if (f == name) {
                    fractal_post_function = presets_functions[f]["id"];
                    if (presets_functions[f]["radius"] != null) {
                        radius = presets_functions[f]["radius"];
                    } else {
                        for (f in presets_fractals) {
                            if (presets_fractals[f]["id"] == fractal_type) {
                                radius = presets_fractals[f]["radius"];
                            }
                        };
                    }
                }
            };

            update_formula();
            update_ui();

            drawMain();
            drawJul();
        }

        function updateSettings() {
            radius = parseFloat(document.getElementById("radius").value);
            max_iterations = parseInt(document.getElementById("iterations").value);
            julia_constant[0] = parseFloat(document.getElementById("constantRe").value);
            julia_constant[1] = parseFloat(document.getElementById("constantIm").value);
            color_offset = parseFloat(document.getElementById("coloroffset").value);
            main_jul_lerp = parseFloat(document.getElementById("nji").value);
            
            drawMain();
            drawJul();
        }

        function updatePowerFloat() {
            power_slider_float = 1;
            mandelbrot_power = parseFloat(document.getElementById("powerfloat").value);

            update_formula();

            drawMain();
            drawJul();
        }
        function updatePowerInt() {
            power_slider_float = 0;
            mandelbrot_power = parseFloat(document.getElementById("powerint").value);

            update_formula();

            drawMain();
            drawJul();
        }

        function setFractal(type) {
            fractal_type = presets_fractals[type]["id"];
            radius = presets_fractals[type]["radius"];

            for (f in presets_functions) {
                if (presets_functions[f]["id"] == fractal_post_function) {
                    fractal_post_function = presets_functions[f]["id"];
                    if (presets_functions[f]["radius"] != null) {
                        radius = presets_functions[f]["radius"];
                    }
                }
            };
            
            update_ui();
            update_formula();

            drawMain();
            drawJul();
        }

        function setColormap(name) {
            colorscheme = presets_colormaps[name]["id"];

            document.getElementById("description_colorscheme").innerHTML = presets_colormaps[name]["description"];

            drawMain();
            drawJul();
        }

        function setColormethod(name) {
            color_method = presets_colormethods[name]["id"];

            document.getElementById("description_colormethod").innerHTML = presets_colormethods[name]["description"];

            drawMain();
            drawJul();
        }

        function drawMain() {
            create_url_params();
            uniform(glmain, programMain,
                [canvasMain.clientWidth, canvasMain.clientHeight],
                [center_x_main, center_y_main],
                [0, 0],
                scale_factor_main,
                radius,
                0,
                max_iterations,
                fractal_type,
                colorscheme,
                color_offset,
                color_method,
                main_jul_lerp,
                mandelbrot_power,
                fractal_post_function
            );

            glmain.drawArrays(glmain.TRIANGLE_FAN, 0, 4);
        }

        function drawJul() {
            create_url_params();
            uniform(gljul, programJul,
                [canvasJul.clientWidth, canvasJul.clientHeight],
                [center_x_jul, center_y_jul],
                julia_constant,
                scale_factor_jul,
                radius,
                1,
                max_iterations,
                fractal_type,
                colorscheme,
                color_offset,
                color_method,
                main_jul_lerp,
                mandelbrot_power,
                fractal_post_function
            );

            gljul.drawArrays(gljul.TRIANGLE_FAN, 0, 4);
        }

        var center_x_main = 0;
        var center_y_main = 0;
        var scale_factor_main = 1 / 2.5;
        var mouse_x_main = 0;
        var mouse_y_main = 0;
        var mouse_clicked_main = false;
        var mouse_clicked_right_main = false;
        function updateMouseCoords_main(e) {
            mouse_x_main = (2 * (e.pageX - e.target.offsetLeft) - canvasMain.clientWidth ) / Math.min(canvasMain.clientWidth, canvasMain.clientHeight);
            mouse_y_main = (2 * (e.pageY - e.target.offsetTop ) - canvasMain.clientHeight) / Math.min(canvasMain.clientWidth, canvasMain.clientHeight);
            mouse_y_main *= -1;
            mouse_x_main = mouse_x_main / scale_factor_main + center_x_main;
            mouse_y_main = mouse_y_main / scale_factor_main + center_y_main;
        }
        function on_zoom_main(e) {
            e.preventDefault();
            var zoom = Math.exp(-e.deltaY / 500);
            updateMouseCoords_main(e);
            center_x_main = mouse_x_main + (center_x_main - mouse_x_main) / zoom;
            center_y_main = mouse_y_main + (center_y_main - mouse_y_main) / zoom;
            scale_factor_main *= zoom;
            drawMain();
        }
        function mouse_down_main(e) {
            if (e.button == 0) {
                mouse_clicked_main = true;
                updateMouseCoords_main(e);
                julia_constant[0] = mouse_x_main;
                julia_constant[1] = mouse_y_main;
                document.getElementById("constantRe").value = mouse_x_main;
                document.getElementById("constantIm").value = mouse_y_main;
                drawJul();
            }
            if (e.button == 2) {
                mouse_clicked_right_main = true;
            }
            updateMouseCoords_main(e);
        }
        function mouse_up_main(e) {
            if (e.button == 0) {
                mouse_clicked_main = false;
                
            }
            if (e.button == 2) {
                mouse_clicked_right_main = false;
            }
        }
        function mouse_move_main(e) {
            if (mouse_clicked_main) {
                updateMouseCoords_main(e);
                julia_constant[0] = mouse_x_main;
                julia_constant[1] = mouse_y_main;
                document.getElementById("constantRe").value = mouse_x_main;
                document.getElementById("constantIm").value = mouse_y_main;
                drawJul();
            }
            if (mouse_clicked_right_main) {
                var old_x = mouse_x_main;
                var old_y = mouse_y_main;
                updateMouseCoords_main(e);
                center_x_main += old_x - mouse_x_main;
                center_y_main += old_y - mouse_y_main;
                updateMouseCoords_main(e);
                drawMain();
            }
        }

        var center_x_jul = 0;
        var center_y_jul = 0;
        var scale_factor_jul = 1 / 2.5;
        var mouse_x_jul = 0;
        var mouse_y_jul = 0;
        var mouse_moved_jul = false;
        var mouse_clicked_right_jul = false;
        function updateMouseCoords_jul(e) {
            mouse_x_jul = (2 * (e.pageX - e.target.offsetLeft) - canvasJul.clientWidth ) / Math.min(canvasJul.clientWidth, canvasJul.clientHeight);
            mouse_y_jul = (2 * (e.pageY - e.target.offsetTop ) - canvasJul.clientHeight) / Math.min(canvasJul.clientWidth, canvasJul.clientHeight);
            mouse_y_jul *= -1;
            mouse_x_jul = mouse_x_jul / scale_factor_jul + center_x_jul;
            mouse_y_jul = mouse_y_jul / scale_factor_jul + center_y_jul;
        }
        function on_zoom_jul(e) {
            e.preventDefault();
            var zoom = Math.exp(-e.deltaY / 500);
            updateMouseCoords_jul(e);
            center_x_jul = mouse_x_jul + (center_x_jul - mouse_x_jul) / zoom;
            center_y_jul = mouse_y_jul + (center_y_jul - mouse_y_jul) / zoom;
            scale_factor_jul *= zoom;
            drawJul();
        }
        function mouse_down_jul(e) {
            if (e.button == 2) {
                mouse_clicked_right_jul = true;
            }
            updateMouseCoords_jul(e);
        }
        function mouse_up_jul(e) {
            if (e.button == 2) {
                mouse_clicked_right_jul = false;
            }
        }
        function mouse_move_jul(e) {
            if (mouse_clicked_right_jul) {
                var old_x = mouse_x_jul;
                var old_y = mouse_y_jul;
                updateMouseCoords_jul(e);
                center_x_jul += old_x - mouse_x_jul;
                center_y_jul += old_y - mouse_y_jul;
                updateMouseCoords_jul(e);
                drawJul();
            }
        }

        function exportMain() {
            var canvas = document.createElement("canvas");
            canvas.width = canvasMain.width;
            canvas.height = canvasMain.height;
            canvas.getContext("2d").drawImage(canvasMain, 0, 0);
            var image = canvas.toDataURL("image/png");
            var a = document.createElement("a");
            a.href = image;
            a.download = "fractal.png";
            a.click();
            a.remove();
            canvas.remove();
        }
        
        function exportJul() {
            var canvas = document.createElement("canvas");
            canvas.width = canvasJul.width;
            canvas.height = canvasJul.height;
            canvas.getContext("2d").drawImage(canvasJul, 0, 0);
            var image = canvas.toDataURL("image/png");
            var a = document.createElement("a");
            a.href = image;
            a.download = "fractal.png";
            a.click();
            a.remove();
            canvas.remove();
        }

        function create_url_params() {
            var url = new URL("https://davidsaltacc.github.io/pages/generative-art/fractals");
            var params = url.searchParams;
            params.append("cxm", center_x_main);
            params.append("cym", center_y_main);
            params.append("cxj", center_x_jul);
            params.append("cyj", center_y_jul);
            params.append("cx", julia_constant[0]);
            params.append("cy", julia_constant[1]);
            params.append("scm", scale_factor_main);
            params.append("scj", scale_factor_jul);
            params.append("r", radius);
            params.append("i", max_iterations);
            params.append("cm", color_method);
            params.append("cs", colorscheme);
            params.append("co", color_offset);
            params.append("f", fractal_type);
            params.append("nji", main_jul_lerp);
            params.append("mp", mandelbrot_power);
            params.append("pf", power_slider_float);
            params.append("fpf", fractal_post_function);
            document.getElementById("url").innerText = document.getElementById("url").href = url.href;
        }
        

        function apply_url_params() {
            var params = (new URL(window.location.href)).searchParams;
            center_x_main = parseFloat(params.get("cxm") ?? center_x_main);
            center_y_main = parseFloat(params.get("cym") ?? center_y_main);
            center_x_jul = parseFloat(params.get("cxj") ?? center_x_jul);
            center_y_jul = parseFloat(params.get("cyj") ?? center_y_jul);
            julia_constant[0] = parseFloat(params.get("cx") ?? julia_constant[0]);
            julia_constant[1] = parseFloat(params.get("cy") ?? julia_constant[1]);
            scale_factor_main = parseFloat(params.get("scm") ?? scale_factor_main);
            scale_factor_jul = parseFloat(params.get("scj") ?? scale_factor_jul);
            radius = parseInt(params.get("r") ?? radius);
            max_iterations = parseInt(params.get("i") ?? max_iterations);
            color_method = parseInt(params.get("cm") ?? color_method);
            colorscheme = parseInt(params.get("cs") ?? colorscheme);
            color_offset = parseFloat(params.get("co") ?? color_offset);
            fractal_type = parseInt(params.get("f") ?? fractal_type);
            main_jul_lerp = parseFloat(params.get("nji") ?? main_jul_lerp);
            mandelbrot_power = parseFloat(params.get("mp") ?? mandelbrot_power);
            power_slider_float = parseInt(params.get("pf") ?? power_slider_float);
            fractal_post_function = parseInt(params.get("fpf") ?? fractal_post_function);

            update_ui()
            update_formula();
        }

        function contextlost() {
            alert("Your WebGL seems to have crashed. This is mainly caused, by rendering a too large or resource-intensive image. Please refresh this page (you can save your settings with the link below).");
        }

        canvasMain.onwheel = on_zoom_main;
        canvasMain.onmousedown = mouse_down_main;
        canvasMain.onmouseup = mouse_up_main;
        canvasMain.onmousemove = mouse_move_main;
        
        canvasJul.onwheel = on_zoom_jul;
        canvasJul.onmousedown = mouse_down_jul;
        canvasJul.onmouseup = mouse_up_jul;
        canvasJul.onmousemove = mouse_move_jul;

        canvasMain.addEventListener("webglcontextlost", contextlost);

        document.body.onload = function() {
            programMain = loadShaders(glmain);
            programJul = loadShaders(gljul);

            apply_url_params();
            drawMain();
            drawJul();

            document.getElementById("statusbar").remove();
        }

    </script>
</body>
</html>